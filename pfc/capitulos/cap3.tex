\chapter{Revisão de Conceitos Básicos} \label{cap:concepts}
Este capítulo tem como objetivo apresentar alguns conceitos utilizados como base para a realização do presente trabalho. Algumas tecnologias serão expostas para facilitar o entendimento dos próximos capítulos. Também é discutido onde foi feito a utilização destas ferramentas e teorias no decorrer do trabalho, bem como as dificuldades encontradas.
% *************
% Métodos Ágeis
% *************
\section{Métodos Ágeis de Desenvolvimento de Software}

% *****
% Agile
% *****
\subsection{Agile}
\textit{Agile} (desenvolvimento ágil de software ou métodos ágeis) é um termo que se refere a abordagem de desenvolvimento de software em que requisitos e soluções evoluem através de um esforço colaborativo de times auto-geridos e multi-funcionais, de sues clientes e usuários finais \cite{agile-definition}. O conceito prega planejamentos adaptativos, desenvolvimento iterativo com melhorias contínuas e encoraja a rápida e flexível resposta a mudanças. O conceito é frequentemente posto em prática com o uso de frameworks de desenvolvimento, como \textit{Scrum} e \textit{Kanban}. O termo foi popularizado através do manifesto ágil de desenvolvimento de software \cite{agile-manifet}, que tem como valores:

\begin{itemize}
    \item Indivíduos e iterações mais que processos e ferramentas;
    \item Software funcional mais que documentação abrangente;
    \item Colaboração do cliente mais que negociação de contratos;
    \item Responder a mudanças mais que seguir um plano.
\end{itemize}

% *****
% Scrum
% *****
\subsection{Scrum}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{pfc/figuras/scrum.pdf}
    \caption{Estrutura do Scrum}
    \label{fig:scrum}
\end{figure}

\textit{Scrum} (Figura \ref{fig:scrum}) \cite{scrum-guide} é um framework com o propósito de abordar problemas adaptativos complexos. Ele não é um processo, técnica ou método definitivo, mas sim uma estrutura para empregar vários processos e técnicas. O framework fundamenta-se nos conceitos de transparência, inspeção e adaptação e tem como valores: compromisso, coragem, foco, abertura e respeito.

O \textit{Scrum} consiste em times com atribuições associadas, eventos e artefatos. Estes elementos são elencados a seguir:
\begin{itemize}
    \item Atribuições nos times:
    \begin{itemize}
        \item \textit{Product Owner}: responsável por maximizar o valor do produto resultante do trabalho do time de desenvolvimento. É uma única pessoal responsável por gerenciar o backlog do produto (\textit{Product Backlog}).
        \item \textit{Development Team}: é o time de desenvolvimento. Estes devem ter seus respectivos trabalhos auto-geridos de tal forma a aumentar a eficiência e eficacia do projeto.
        \item \textit{Scrum Master}: responsável por promover e dar apoio as regras do \textit{Scrum} dentro do time. Esta pessoa deve ajudar os demais a compreender a teoria por trás do framework, práticas, regras e valores.
    \end{itemize}
    \item Eventos:
    \begin{itemize}
        \item \textit{Sprint}: é o evento central do \textit{Scrum}, consistindo de uma janela limitada de tempo com duração de um mês ou menos. Durante este período temporal, a equipe deve concluir um versão incremental do produto a ser entregue. As durações das \textit{sprints} devem ser consistentes ao longo do projeto, com uma \textit{sprint} iniciando-se imediatamente ao término da anterior.
        \item \textit{Sprint Planning}: o trabalho a ser realizado durante a \textit{sprint} é planejado durante a sessão de \textit{sprint planning} através do trabalho colaborativo de todos os membros do time. A duração deste evento deve ser limitado proporcionalmente ao tamanho da janela de tempo da \textit{sprint}, sendo $8h$ o limite para uma sprint de um mês
        \item \textit{Daily Scrum}: é um evento diário executado pelo time de desenvolvimento, limitado a quinze minutos. Ocorre todos os dias no mesmo horário com o objetivo de inspecionar o trabalho executado no dia anterior e anteceder discussões sobre o trabalho futuro.
        \item \textit{Sprint Review}: evento que ocorre ao final da \textit{sprint} com o intuito de avaliar o progresso do time em relação ao incremento do produto. Durante a sessão, limita a $4h$ para uma \textit{sprint} de um mês, o time e \textit{stakeholders} discutem o que foi feito e proveem feedback.
        \item \textit{Sprint Retrospective}: evento que ocorre após a \textit{sprint review} e antecede a \textit{sprint planning}, limitado a $3h$ para uma \textit{sprint} de um mês. Durante o evento, o time tem a oportunidade de avaliar seu próprio desempenho e criar um plano de melhorias a serem alcançados na próxima \textit{sprint}.
    \end{itemize}
    \item Artefatos:
    \begin{itemize}
        \item \textit{Product Backlog}: consiste em uma lista ordenada de todas as tarefas a serem executadas que são de conhecimento até o momento. É uma única fonte de requisitos para qualquer mudança a ser implementada no produto. Ele nunca está completo, mudando constantemente conforme a evolução do produto. Ele lista todas as funcionalidades, requisitos, melhorias e consertos que devem ser aplicados ao produto, bem como uma descrição do que é considerada uma tarefa completa.
        \item \textit{Sprint Backlog}: é um conjunto de itens selecionados do \textit{backlog} do produto com um plano do incremento do produto que será entregue ao final da \textit{sprint}.
    \end{itemize}
\end{itemize}

% *******************
% Desenvolvimento iOS
% *******************
\section{Desenvolvimento de Aplicativos iOS}
A seguir são apresentados os conceitos da arquitetura da plataforma, ambiente de desenvolvimento, linguagens de programação e gerenciamento de dependências, os quais permitem que programadores desenvolvam, instalem, executem e testem aplicativos em simuladores e dispositivos físicos.

\subsection{Arquitetura da Plataforma}
O sistema operacional iOS \cite{ios-system} foi criado e é desenvolvido pela Apple Inc. com o intuito de dar suporte aos dispositivos móveis da empresa (iPhone, iPod Touch e iPad). O sistema ainda originou
outros sistemas operacionais da empresa, como o watchOS \cite{watchos} destinado ao Apple Watch, e ao tvOS \cite{tvos}, destinado à Apple TV. 

O sistema operacional iOS gerencia o hardware do dispositivo e fornece as tecnologias necessárias para o desenvolvimento de aplicativos nativos. A arquitetura da plataforma consiste em quatro camadas de abstração (Figura \ref{fig:ios-architecture}). As camadas superiores, próximas ao nível da aplicação, são criadas a partir das camadas inferiores, as quais estão mais próximas ao nível do hardware. Elas exercem as seguintes funcionalidades:
\begin{itemize}
    \item Cocoa Touch: é a camada de abstração mais acima da arquitetura. Contém frameworks essenciais que são base das aplicações nativas para iOS, sendo o mais utilizado o UIKit framework. Esta camada define a infraestrutura básica a nível de aplicação, provendo grande quantidade de tecnologias chave do sistema, como entradas de resposta ao toque.
    \item Media: responsável pelo gerenciamento de mídias (gráficos, áudio e vídeo).
    \item Core Services: responsável por gerencias os serviços fundamentais do sistema que as aplicações consomem. A camada Cocoa Touch depende diretamente da Core Service para algumas de suas funcionalidades. O framework básico desta camada é denominado Foundation.
    \item Core OS: gerencia as funcionalidades de baixo nível do dispositivo, provendo frameworks que podem ser acessados pela aplicação.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{pfc/figuras/ios-architecture.png}
    \caption{Camadas de abstração do sistema iOS}
    \label{fig:ios-architecture}
\end{figure}

\subsection{Ambiente de Desenvolvimento Xcode}
O Xcode é o ambiente de desenvolvimento integrado (IDE) da Apple \cite{xcode}. A ferramenta possui um editor de texto integrado, uma ferramenta de construção de interfaces (\textit{interface builder}) e outras funcionalidades que dão suporte ao desenvolvimento de aplicativos para os sistemas iOS, macOS, watchOS e tvOS. O Xcode possui o SDK iOS integrado, o qual permite a compilação, a simulação de dispositivos, entre outros recursos.

A Figura \ref{fig:xcode} ilustra a interface gráfica da IDE.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{pfc/figuras/xcode.png}
    \caption{Interface gráfica da IDE Xcode}
    \label{fig:xcode}
\end{figure}

\subsection{Linguagens de Programação}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{pfc/figuras/swift.png}
    \caption{Logo da linguagem de programação Swift}
    \label{fig:swift}
\end{figure}
As linguagens de programação com suporte oficial da Apple para desenvolvimento de aplicativos nativos para iOS são Swift e Objective-C. Até a versão iOS 7 (hoje se encontra na versão 12), o Objective-C era a linguagem oficialmente utilizada. Desde o lançamento do Swift em 2014 pela Apple, a linguagem tem crescido rapidamente em popularidade e uso, aparecendo no ranking das dez primeiras linguagens de programação utilizadas por desenvolvedores \cite{redmonk}. A nova linguagem tem suporte para o desenvolvimento nas plataformas iOS, macOS, watchOS, e tvOS e pode ser utilizada em conjunto com o Objective-C no mesmo projeto. A compatibilidade com a antiga linguagem, permite que novos projetos em Swift utilizem bibliotecas já implementadas em Objective-C, fato que consolidou a nova linguagem como recomendada para novas aplicações.

O Swift traz diversos benefícios em relação ao Objective-C, a qual é considerada uma linguagem difícil de alcançar proficiência, tanto para programadores vindos de outras linguagens quanto para iniciantes. O Swift foi arquitetado para operar de forma segura, prevendo erros humanos, e para dar suporte as melhores práticas de programação. Algumas funcionalidades que dão suporte a essas premissas são a introdução de estruturas de dados mais sofisticadas (como tuplas) e o fato da linguagem assegurar a tipagem de dados, prevendo erros de passagem errônea de dados, e oferecer valores opcionais (\textit{Optionals}), prevendo erros de ponteiros nulos recorrentes no Objective-C por exemplo. Tendo em vista o que foi citado, a linguagem Swift foi a escolhida para o desenvolvimento do aplicativo deste trabalho.

\subsection{Gerenciamento de Dependências}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{pfc/figuras/cocoapods.png}
    \caption{Logo do gerenciador de dependências CocoaPods}
    \label{fig:cocoapods}
\end{figure}
O uso de gerenciadores de dependências, para controlar a utilização de bibliotecas externas no projeto, é um padrão para o desenvolvimento iOS. Uma das ferramentas mais frequentes em projetos é o CocoaPods (Figura \ref{fig:cocoapods}), com mais de $53$ mil bibliotecas disponíveis e mais de $3$ milhões de aplicativos utilizando a ferramenta \cite{cocoapods}.

% ***********
% RESTful API
% ***********
\section{RESTful API's}
Um dos tipos mais populares de API é a baseada na arquitetura REST (\textit{Representational State Transfer}), a qual consiste em uma abstração dos elementos arquitetônicos dentro de um sistema hipermídia distribuído \cite{rest-api}. 
RESTful APIs foram projetadas para se beneficiar de protocolos existentes, utilizando o HTTP para web API's. Uma das vantagens da abordagem é o ganho de flexibilidade, já que dados não são atrelados a recursos ou métodos, permitindo a manipulação de múltiplos tipos de chamadas com diferentes formatos de retorno de dados. Esta flexibilidade permite a construção de API's que atendem a necessidade de todas as partes envolvidas no projeto. As seguintes características são observadas em RESTful API's:

\begin{itemize}
    \item Cliente e servidor devem estar separados e podem evoluir individualmente.
    \item Não armazenam estado, significando que todas as chamadas da API operam independentemente. Cada uma delas contém todos os dados necessários para serem completadas.
    \item Devido ao fator de não armazenar estado, RESTful API's são projetadas para utilizar sistemas de armazenamento em cache
    \item Possuem diferentes camadas operando em conjunto para a construção de uma hierarquia que auxilia a criação de aplicações mais escaláveis e modulares.
    \item Não está restrita a um tipo de formato de transmissão de dados (pode transferir dados em diferentes formatos como XML e JSON). E usuários não necessitam conhecer nomes de procedimentos ou parâmetros em uma ordem específica.
\end{itemize}

% ********************
% Back-end
% ********************
\section{Back-end}
Front-end e back-end são termos utilizados para caracterizar interfaces e serviços de um sistema de software. Os termos são utilizados para separar as responsabilidades das camadas de apresentação (front-end) e da camada de acesso a dados (back-end). A parte da aplicação em que o usuário realiza interações de forma direta é atribuída ao front-end. Enquanto o back-end tem a responsabilidade de prover a infraestrutura da aplicação. O back-end também fornece serviços para que o front-end apresente e colete os dados da aplicação. Dentro desses serviços estão a implementação de lógicas de negócio do sistema e envio e armazenamento de dados. Em aplicações móveis, é comum a presença de um back-end localizado em servidor web, provendo os mesmos serviços para todos os usuários.

% ********************
% Testes Automatizados
% ********************
\section{Testes de Software}
Um teste de software é o processo de avaliar se um sistema ou seus componentes satisfazem requisitos especificados \cite{software-testing}. Testes fazem parte do controle de qualidade de um produto ou serviço. A área de estudo de testes de software é vasta, contemplando diversos tipos de testes com diferentes propósitos e maneiras de serem implementados, como os que seguem:

\begin{itemize}
    \item Teste de fumaça: checagem básica das funcionalidade do software;
    \item Teste de regressão: detecção de erros após mudanças no código;
    \item Teste de aceitação: verificação se a solução funciona para o usuário;
    \item Teste de usabilidade: verificação da facilidade de uso do sistema;
    \item Teste exploratório: uso do sistema de forma não-determinística.
\end{itemize}

\subsection{Testes Automatizados}
Testes automatizados consistem em qualquer tipo de teste que é executado e tem seus resultados verificados de forma automática. Testes deste tipo podem ser utilizados para substituir ou complementar os realizados manualmente, os quais podem ser por vezes tediosos, propensos a erros humanos e custosos. Geralmente são escritos para serem executados diversas vezes no decorrer do projeto.

Os testes automatizados podem ser realizados em diferentes camadas do sistema de software. A pirâmide de automação de testes \cite{test-pyramid} (Figura \ref{fig:piramid}) ilustra os diferentes níveis. Na base da pirâmide, encontram-se os testes unitários, referentes a funcionalidade de um componente do software. Na camada intermediária, estão os testes de serviço ou de integração, responsáveis por testar a interação entre diferentes componentes em resposta a entradas no sistema. No topo, localizam-se os testes de interface gráfica (ou de UI, do inglês \textit{User Interface}), os quais simulam o comportamento do usuário final do sistema frente a interface gráfica do software. A pirâmide tem como propósito indicar onde os esforços devem estar concentrado para se obter o melhor retorno de investimento, sendo na base onde os testes devem ocorrer com maior frequência.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pfc/figuras/piramid.png}
    \caption{Pirâmide de testes automatizados}
    \label{fig:piramid}
\end{figure}

\subsubsection{Implementação de Testes Automatizados de Interface Gráfica}
A implementação de testes automatizados é realizada com o auxílio de ferramentas que devem desempenhar três tipos de comandos:

\begin{itemize}
    \item Seleção: localiza os elementos da interface gráfica. A seleção pode ser realizada de diversas formas, como através do identificador de acessibilidade do componente (utilizado para inclusão digital de pessoas com deficiência visual), pela hierarquia de componentes da interface ou pelo valor de alguma propriedade do elemento (como o texto dentro de um botão). A seleção de elementos através do identificador de acessibilidade costuma ser a melhor prática a ser adotada, uma vez que esta permite a identificação única do componente.
    \item Ação: realiza interações a partir dos elementos selecionados da interface. Diversos tipos de ações podem ser performadas de acordo com o tipo de interface sendo testada. Para dispositivos móveis, ações com pressionar botões, inserir caracteres em campos de texto ou movimentar a tela em diferentes direções podem ser feitas.
    \item Asserção: checa uma condição lógica, estado ou comportamento relativo à interface. Exemplos de asserção são a checagem da visibilidade de elementos da tela ou a verificação de valores corretos apresentados de acordo com os esperados.
\end{itemize}
